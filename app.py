from flask import Flask, render_template, request, send_file, redirect, url_for, flash
from werkzeug.utils import secure_filename
import os
import json
import zipfile
from datetime import datetime

app = Flask(__name__)
app.secret_key = "replace-this-with-a-random-secret"
UPLOAD_FOLDER = "uploads"
OUTPUT_FOLDER = "outputs"
ALLOWED_EXTENSIONS = {"ipynb"}

os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS

def sanitize_filename(name: str) -> str:
    keep = "-_.()[] "
    return "".join(c for c in name if c.isalnum() or c in keep).strip() or "notebook"

def extract_code_cells(nb_json):
    cells = nb_json.get("cells", [])
    code_cells = []
    for idx, cell in enumerate(cells, start=1):
        if cell.get("cell_type") == "code":
            src = cell.get("source", "")
            # source can be a list of lines or a single string
            if isinstance(src, list):
                code = "".join(src)
            else:
                code = src or ""
            code_cells.append((idx, code))
    return code_cells

def write_separate_py_files(code_cells, base_name, out_dir):
    written = []
    for n, (cell_index, code) in enumerate(code_cells, start=1):
        filename = f"{base_name}_cell_{n:03d}.py"
        path = os.path.join(out_dir, filename)
        header = (
            f"# Extracted from cell #{cell_index}\n"
            "# Generated by Notebook to Python file Converter\n\n"
        )
        with open(path, "w", encoding="utf-8") as f:
            f.write(header + code + ("\n" if not code.endswith("\n") else ""))
        written.append(path)
    return written

def write_combined_py(code_cells, base_name, out_dir):
    filename = f"{base_name}_combined.py"
    path = os.path.join(out_dir, filename)
    with open(path, "w", encoding="utf-8") as f:
        f.write("# -*- coding: utf-8 -*-\n")
        f.write(f"# Combined Python file extracted from notebook '{base_name}'.ipynb\n")
        f.write("# Sections correspond to notebook code cells.\n")
        f.write("# Generated by Notebook to Python file Converter\n\n")
        for n, (cell_index, code) in enumerate(code_cells, start=1):
            f.write(f"\n# ==== Cell {n} (original #{cell_index}) ====\n")
            f.write(code)
            if not code.endswith("\n"):
                f.write("\n")
    return path

def zip_outputs(paths, base_name, out_dir):
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    zip_name = f"{base_name}_py_cells_{ts}.zip"
    zip_path = os.path.join(out_dir, zip_name)
    with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
        for p in paths:
            arcname = os.path.basename(p)
            zf.write(p, arcname=arcname)
    return zip_path

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        if "file" not in request.files:
            flash("No file part in the form.")
            return redirect(request.url)
        file = request.files["file"]
        if file.filename == "":
            flash("No file selected.")
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            base_name = sanitize_filename(os.path.splitext(filename)[0])
            save_path = os.path.join(UPLOAD_FOLDER, filename)
            file.save(save_path)

            # Read notebook JSON
            try:
                with open(save_path, "r", encoding="utf-8") as f:
                    nb_json = json.load(f)
            except Exception as e:
                flash(f"Failed to read notebook: {e}")
                return redirect(request.url)

            code_cells = extract_code_cells(nb_json)
            if not code_cells:
                flash("No code cells found in the notebook.")
                return redirect(request.url)

            # Prepare output directory per upload
            out_dir = os.path.join(OUTPUT_FOLDER, base_name)
            os.makedirs(out_dir, exist_ok=True)

            written_paths = write_separate_py_files(code_cells, base_name, out_dir)
            combined_path = write_combined_py(code_cells, base_name, out_dir)

            # Create zip of separate files + combined file
            zip_path = zip_outputs(written_paths + [combined_path], base_name, out_dir)
            return redirect(url_for("download_file", path=zip_path))
        else:
            flash("Unsupported file type. Please upload a .ipynb file.")
            return redirect(request.url)
    return render_template("index.html")

@app.route("/download")
def download_file():
    path = request.args.get("path")
    if not path or not os.path.exists(path):
        flash("Download file not found.")
        return redirect(url_for("index"))
    return send_file(path, as_attachment=True, download_name=os.path.basename(path))

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
